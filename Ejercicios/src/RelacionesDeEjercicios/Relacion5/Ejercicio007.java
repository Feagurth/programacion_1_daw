/*
 * Copyright (C) 2014 Luis Cabrerizo Gómez
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package RelacionesDeEjercicios.Relacion5;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFrame;

/**
 * Clase para crear una calculadora
 *
 * @author Luis Cabrerizo Gómez
 */
public class Ejercicio007 extends javax.swing.JFrame {

    // Variables de estado para comprobar si se introduce una nueva operación
    // o un nuevo número
    private boolean nuevoNumero = true;
    private boolean nuevaOperacion = false;

    private final int PRECISION = 15;

    /**
     * Crea un nuevo formulario FormCalculadora
     */
    public Ejercicio007() {
        initComponents();

        // Asignamos una precisión específica a las divisiones de la calculadora
        ParserCalculadora.setPrecision(PRECISION);

        // Eliminamos el gestor de capas que haya predefinido
        this.setLayout(null);

        // Asignamos un icono al JFrame
        try {
            this.setIconImage(ImageIO.read(new File("./resources/icon.png")));
        } catch (IOException ex) {
            Logger.getLogger(Ejercicio007.class.getName()).log(Level.SEVERE, null, ex);
        }

        // Le permitimos que coja el fojo
        this.setFocusable(true);

        // Y se lo asignamos para permitir que salten eventos al pulsar los 
        // botones del teclado
        this.requestFocus();

        // Ponemos un título a la ventana
        this.setTitle("Calculadora");

        // Y le decimos que se situe en el centro de la pantalla al iniciar
        this.setLocationRelativeTo(null);

        // Creamos una objeto de tipo KeyListener para controlar el teclado
        KeyListener controlTeclado = new ControlTeclado();

        // Asignamos el keylistener al JFrame para permitirnos controlar
        // las pulsaciones en el teclado
        this.addKeyListener(controlTeclado);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtHistorial = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtResultado = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jPanel3 = new javax.swing.JPanel();
        btnFactorizar = new javax.swing.JButton();
        btnSeno = new javax.swing.JButton();
        btnLogNeperiano = new javax.swing.JButton();
        btnEElevadoX = new javax.swing.JButton();
        btnValorAbsoluto = new javax.swing.JButton();
        btnPi = new javax.swing.JButton();
        btnXCuadrado = new javax.swing.JButton();
        btnLogaritmo = new javax.swing.JButton();
        btnCoseno = new javax.swing.JButton();
        btnRaizCuadrada = new javax.swing.JButton();
        btnE = new javax.swing.JButton();
        btnYElevadoX = new javax.swing.JButton();
        btnInversa = new javax.swing.JButton();
        btnTangente = new javax.swing.JButton();
        btnPorcentaje = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        btnUno = new javax.swing.JButton();
        btnCuatro = new javax.swing.JButton();
        btnLimpiar = new javax.swing.JButton();
        btnSiete = new javax.swing.JButton();
        btnCero = new javax.swing.JButton();
        btnDos = new javax.swing.JButton();
        btnCinco = new javax.swing.JButton();
        btnPunto = new javax.swing.JButton();
        btnOcho = new javax.swing.JButton();
        btnDividir = new javax.swing.JButton();
        btnTres = new javax.swing.JButton();
        btnSeis = new javax.swing.JButton();
        btnMasMenos = new javax.swing.JButton();
        btnNueve = new javax.swing.JButton();
        btnMultiplicar = new javax.swing.JButton();
        btnParentesis = new javax.swing.JButton();
        btnMas = new javax.swing.JButton();
        btnIgual = new javax.swing.JButton();
        btnMenos = new javax.swing.JButton();
        btnBorrar = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JSeparator();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jScrollPane1.setBorder(null);
        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        txtHistorial.setFont(new java.awt.Font("Dialog", 0, 18)); // NOI18N
        txtHistorial.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        txtHistorial.setAutoscrolls(true);
        txtHistorial.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        txtHistorial.setMinimumSize(new java.awt.Dimension(0, 550));
        jScrollPane1.setViewportView(txtHistorial);

        jScrollPane2.setBorder(null);
        jScrollPane2.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        txtResultado.setFont(new java.awt.Font("Dialog", 0, 36)); // NOI18N
        txtResultado.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        txtResultado.setAutoscrolls(true);
        jScrollPane2.setViewportView(txtResultado);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addComponent(jScrollPane2)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel3.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        btnFactorizar.setText("x!");
        btnFactorizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnFactorizarActionPerformed(evt);
            }
        });

        btnSeno.setText("Sin");
        btnSeno.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSenoActionPerformed(evt);
            }
        });

        btnLogNeperiano.setText("Ln");
        btnLogNeperiano.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLogNeperianoActionPerformed(evt);
            }
        });

        btnEElevadoX.setText("e^x");
        btnEElevadoX.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEElevadoXActionPerformed(evt);
            }
        });

        btnValorAbsoluto.setText("|x|");
        btnValorAbsoluto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnValorAbsolutoActionPerformed(evt);
            }
        });

        btnPi.setText("π");
        btnPi.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPiActionPerformed(evt);
            }
        });

        btnXCuadrado.setText("x^2");
        btnXCuadrado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnXCuadradoActionPerformed(evt);
            }
        });

        btnLogaritmo.setText("Log");
        btnLogaritmo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLogaritmoActionPerformed(evt);
            }
        });

        btnCoseno.setText("Cos");
        btnCoseno.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCosenoActionPerformed(evt);
            }
        });

        btnRaizCuadrada.setText("√");
        btnRaizCuadrada.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRaizCuadradaActionPerformed(evt);
            }
        });

        btnE.setText("e");
        btnE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEActionPerformed(evt);
            }
        });

        btnYElevadoX.setText("y^x");
        btnYElevadoX.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnYElevadoXActionPerformed(evt);
            }
        });

        btnInversa.setText("1/x");
        btnInversa.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInversaActionPerformed(evt);
            }
        });

        btnTangente.setText("Tan");
        btnTangente.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTangenteActionPerformed(evt);
            }
        });

        btnPorcentaje.setText("%");
        btnPorcentaje.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPorcentajeActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnEElevadoX, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnLogNeperiano, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnSeno, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnFactorizar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnValorAbsoluto, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnXCuadrado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnLogaritmo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnCoseno, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnRaizCuadrada, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnPi, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnYElevadoX, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnInversa, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnTangente, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnPorcentaje, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnE, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(btnPorcentaje, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnTangente, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnInversa, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnYElevadoX, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnE, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(btnRaizCuadrada, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCoseno, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnLogaritmo, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnXCuadrado, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnPi, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(btnFactorizar, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnSeno, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnLogNeperiano, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnEElevadoX, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnValorAbsoluto, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel4.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        btnUno.setText("1");
        btnUno.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUnoActionPerformed(evt);
            }
        });

        btnCuatro.setText("4");
        btnCuatro.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCuatroActionPerformed(evt);
            }
        });

        btnLimpiar.setText("C");
        btnLimpiar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLimpiarActionPerformed(evt);
            }
        });

        btnSiete.setText("7");
        btnSiete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSieteActionPerformed(evt);
            }
        });

        btnCero.setText("0");
        btnCero.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCeroActionPerformed(evt);
            }
        });

        btnDos.setText("2");
        btnDos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDosActionPerformed(evt);
            }
        });

        btnCinco.setText("5");
        btnCinco.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCincoActionPerformed(evt);
            }
        });

        btnPunto.setText(".");
        btnPunto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPuntoActionPerformed(evt);
            }
        });

        btnOcho.setText("8");
        btnOcho.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOchoActionPerformed(evt);
            }
        });

        btnDividir.setText("/");
        btnDividir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDividirActionPerformed(evt);
            }
        });

        btnTres.setText("3");
        btnTres.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnTresActionPerformed(evt);
            }
        });

        btnSeis.setText("6");
        btnSeis.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSeisActionPerformed(evt);
            }
        });

        btnMasMenos.setText("+/-");
        btnMasMenos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMasMenosActionPerformed(evt);
            }
        });

        btnNueve.setText("9");
        btnNueve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNueveActionPerformed(evt);
            }
        });

        btnMultiplicar.setText("*");
        btnMultiplicar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMultiplicarActionPerformed(evt);
            }
        });

        btnParentesis.setText("( )");
        btnParentesis.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnParentesisActionPerformed(evt);
            }
        });

        btnMas.setText("+");
        btnMas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMasActionPerformed(evt);
            }
        });

        btnIgual.setText("=");
        btnIgual.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnIgualActionPerformed(evt);
            }
        });

        btnMenos.setText("-");
        btnMenos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMenosActionPerformed(evt);
            }
        });

        btnBorrar.setText("←");
        btnBorrar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBorrarActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnUno, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnCuatro, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnSiete, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnLimpiar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnCero, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnDos, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnCinco, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnOcho, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnDividir, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnPunto, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnTres, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnSeis, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnNueve, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnMultiplicar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnMasMenos, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnParentesis, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnMas, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnMenos, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnBorrar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnIgual, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(btnBorrar, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnMenos, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnMas, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnParentesis, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnIgual, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(btnMultiplicar, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnNueve, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnSeis, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnTres, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnMasMenos, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(btnDividir, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnOcho, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCinco, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDos, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnPunto, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(btnLimpiar, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnSiete, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCuatro, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnUno, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCero, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        jSeparator2.setOrientation(javax.swing.SwingConstants.VERTICAL);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jSeparator1)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jSeparator2))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Evento para la pulsación del botón de factorización
     *
     * @param evt Evento
     */
    private void btnFactorizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFactorizarActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Fact")) {
            operacionPulsada("Fact");
        }
    }//GEN-LAST:event_btnFactorizarActionPerformed

    /**
     * Evento para la pulsación del botón de raíz cuadrada
     *
     * @param evt Evento
     */
    private void btnRaizCuadradaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRaizCuadradaActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Sqrt")) {
            operacionPulsada("Sqrt");
        }
    }//GEN-LAST:event_btnRaizCuadradaActionPerformed

    /**
     * Evento para la pulsación del botón de porcentaje
     *
     * @param evt Evento
     */
    private void btnPorcentajeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPorcentajeActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "%") && !nuevaOperacion) {
            operacionPulsada("%");
        }
    }//GEN-LAST:event_btnPorcentajeActionPerformed

    /**
     * Evento para la pulsación del botón de reiniciar (clear)
     *
     * @param evt Evento
     */
    private void btnLimpiarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLimpiarActionPerformed
        // Reiniciamos las variables de estado y los cuadros de texto a su estado
        // original
        nuevoNumero = true;
        nuevaOperacion = true;
        txtHistorial.setText("");
        txtResultado.setText("");

        this.requestFocus();
    }//GEN-LAST:event_btnLimpiarActionPerformed
    /**
     * Evento para la pulsación del botón de división
     *
     * @param evt Evento
     */
    private void btnDividirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDividirActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "/") && !nuevaOperacion) {
            operacionPulsada("/");
        }

    }//GEN-LAST:event_btnDividirActionPerformed

    /**
     * Evento para la pulsación del botón de multiplicación
     *
     * @param evt Evento
     */
    private void btnMultiplicarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMultiplicarActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "*") && !nuevaOperacion) {
            operacionPulsada("*");
        }

    }//GEN-LAST:event_btnMultiplicarActionPerformed

    /**
     * Evento para la pulsación del botón de borrado
     *
     * @param evt Evento
     */
    private void btnBorrarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBorrarActionPerformed

        // Verificamos que no sea una nueva operación, así no borramos dígitos
        // del resultado
        if (!nuevaOperacion) {
            // Guardamos el valor del cuadro de texto de resultado a una variable
            // para trabajar con él
            String valor = txtResultado.getText();

            // Si su longitud no es nula, quitamos un caracter y lo asignamos
            // de nuevo al cuadro de texto de resultado
            if (valor.length() > 0) {
                txtResultado.setText(valor.substring(0, valor.length() - 1));
            }
        }
    }//GEN-LAST:event_btnBorrarActionPerformed

    /**
     * Evento para la pulsación del botón del número 7
     *
     * @param evt Evento
     */
    private void btnSieteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSieteActionPerformed
        numeroPulsado("7");
    }//GEN-LAST:event_btnSieteActionPerformed

    /**
     * Evento para la pulsación del botón del número 8
     *
     * @param evt Evento
     */
    private void btnOchoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOchoActionPerformed
        numeroPulsado("8");
    }//GEN-LAST:event_btnOchoActionPerformed
    /**
     * Evento para la pulsación del botón del número 9
     *
     * @param evt Evento
     */
    private void btnNueveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNueveActionPerformed
        numeroPulsado("9");
    }//GEN-LAST:event_btnNueveActionPerformed

    /**
     * Evento para la pulsación del botón del número 4
     *
     * @param evt Evento
     */
    private void btnCuatroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCuatroActionPerformed
        numeroPulsado("4");
    }//GEN-LAST:event_btnCuatroActionPerformed

    /**
     * Evento para la pulsación del botón del número 5
     *
     * @param evt Evento
     */
    private void btnCincoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCincoActionPerformed
        numeroPulsado("5");
    }//GEN-LAST:event_btnCincoActionPerformed

    /**
     * Evento para la pulsación del botón del número 6
     *
     * @param evt Evento
     */
    private void btnSeisActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSeisActionPerformed
        numeroPulsado("6");
    }//GEN-LAST:event_btnSeisActionPerformed

    /**
     * Evento para la pulsación del botón del número 1
     *
     * @param evt Evento
     */
    private void btnUnoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUnoActionPerformed
        numeroPulsado("1");
    }//GEN-LAST:event_btnUnoActionPerformed

    /**
     * Evento para la pulsación del botón del número 2
     *
     * @param evt Evento
     */
    private void btnDosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDosActionPerformed
        numeroPulsado("2");
    }//GEN-LAST:event_btnDosActionPerformed

    /**
     * Evento para la pulsación del botón del número 3
     *
     * @param evt
     */
    private void btnTresActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTresActionPerformed
        numeroPulsado("3");
    }//GEN-LAST:event_btnTresActionPerformed

    /**
     * Evento para la pulsación del botón de suma
     *
     * @param evt Evento
     */
    private void btnMasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMasActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "+") && !nuevaOperacion) {
            operacionPulsada("+");
        }

    }//GEN-LAST:event_btnMasActionPerformed

    /**
     * Evento para la pulsación del botón de resta
     *
     * @param evt Evento
     */
    private void btnMenosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMenosActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "-") && !nuevaOperacion) {
            operacionPulsada("-");
        }

    }//GEN-LAST:event_btnMenosActionPerformed

    /**
     * Evento para la pulsación del botón de punto decimal
     *
     * @param evt
     */
    private void btnPuntoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPuntoActionPerformed
        numeroPulsado(".");
    }//GEN-LAST:event_btnPuntoActionPerformed

    /**
     * Evento para la pulsación del botón del número 0
     *
     * @param evt Evento
     */
    private void btnCeroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCeroActionPerformed
        numeroPulsado("0");
    }//GEN-LAST:event_btnCeroActionPerformed

    /**
     * Evento para la pulsación del botón de negativo
     *
     * @param evt Evento
     */
    private void btnMasMenosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMasMenosActionPerformed

        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "neg")) {
            // Pasamos el valor del cuadro de texto resultado a un variable BigDecimal
            BigDecimal valor = new BigDecimal(txtResultado.getText());

            // Multiplicamos su valor por -1
            valor = valor.multiply(BigDecimal.valueOf(-1));

            // Guardamos el resultado en el cuadro de texto correspondiente
            txtResultado.setText(valor.toString());
        }
    }//GEN-LAST:event_btnMasMenosActionPerformed

    /**
     * Evento para la pulsación del botón de igual
     *
     * @param evt Evento
     */
    private void btnIgualActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnIgualActionPerformed

        if (!nuevaOperacion) {

            if (verficicarFormatoCalculo(txtHistorial.getText(), txtResultado.getText())) {
                // Concatenamos al historial el valor del campo resultado
                txtHistorial.setText(txtHistorial.getText() + txtResultado.getText());

                // Enviamos el historial conteniendo la cadena de operaciones a la 
                // función operar y asignamos el resultado a cuadro de texto resultado
                txtResultado.setText(operar(txtHistorial.getText()));

                // Lo siguiente que se introduzca en la calculadora será una nueva 
                // operación o un nuevo número
                nuevoNumero = true;
                nuevaOperacion = true;
            }
        }

        // Pasamos el foco al JFrame
        this.requestFocus();
    }//GEN-LAST:event_btnIgualActionPerformed

    /**
     * Evento para la pulsación del botón de paréntesis
     *
     * @param evt Evento
     */
    private void btnParentesisActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnParentesisActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "(")) {
            operacionPulsada("(");
        }
    }//GEN-LAST:event_btnParentesisActionPerformed

    /**
     * Evento para la pulsación del botón del número Pi
     *
     * @param evt Evento
     */
    private void btnPiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPiActionPerformed
        // Verificamos que podamos introducir un nuevo número
        // así no concatenamos el número Pi sobre un número a medio escribir
        if (nuevoNumero) {
            numeroPulsado("Pi");
        }

        this.requestFocus();

    }//GEN-LAST:event_btnPiActionPerformed
    /**
     * Evento para la pulsación del botón del número e
     *
     * @param evt Evento
     */
    private void btnEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEActionPerformed
        // Verificamos que podamos introducir un nuevo número
        // así no concatenamos el número Pi sobre un número a medio escribir
        if (nuevoNumero) {
            numeroPulsado("e");
        }

        this.requestFocus();
    }//GEN-LAST:event_btnEActionPerformed

    /**
     * Evento para la pulsación del botón de seno
     *
     * @param evt Evento
     */
    private void btnSenoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSenoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Sin")) {
            operacionPulsada("Sin");
        }
    }//GEN-LAST:event_btnSenoActionPerformed

    /**
     * Evento para la pulsación del botón de coseno
     *
     * @param evt Evento
     */
    private void btnCosenoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCosenoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Cos")) {
            operacionPulsada("Cos");
        }
    }//GEN-LAST:event_btnCosenoActionPerformed

    /**
     * Evento para la pulsación del botón de tangente
     *
     * @param evt Evento
     */
    private void btnTangenteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnTangenteActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Tan")) {
            operacionPulsada("Tan");
        }

    }//GEN-LAST:event_btnTangenteActionPerformed

    /**
     * Evento para la pulsación del botón de logaritmo neperiano
     *
     * @param evt Evento
     */
    private void btnLogNeperianoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLogNeperianoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Ln")) {
            operacionPulsada("Ln");
        }
    }//GEN-LAST:event_btnLogNeperianoActionPerformed

    /**
     * Evento para la pulsación del botón de logaritmo en base 10
     *
     * @param evt Evento
     */
    private void btnLogaritmoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLogaritmoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Log")) {
            operacionPulsada("Log");
        }
    }//GEN-LAST:event_btnLogaritmoActionPerformed

    /**
     * Evento para la pulsación del botón de elevar al cuadrado
     *
     * @param evt Evento
     */
    private void btnXCuadradoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnXCuadradoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "^2")) {
            operacionPulsada("^2");
        }
    }//GEN-LAST:event_btnXCuadradoActionPerformed

    /**
     * Evento para la pulsación del botón de inversa de un número
     *
     * @param evt Evento
     */
    private void btnInversaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnInversaActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Inv")) {
            operacionPulsada("Inv");
        }
    }//GEN-LAST:event_btnInversaActionPerformed

    /**
     * Evento para la pulsación del botón de elevando al cuadrado
     *
     * @param evt Evento
     */
    private void btnYElevadoXActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnYElevadoXActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "^")) {
            operacionPulsada("^");
        }
    }//GEN-LAST:event_btnYElevadoXActionPerformed

    /**
     * Método para la pulsación del botón de valor absoluto
     *
     * @param evt Evento
     */
    private void btnValorAbsolutoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnValorAbsolutoActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "Abs")) {
            operacionPulsada("Abs");
        }
    }//GEN-LAST:event_btnValorAbsolutoActionPerformed

    /**
     * Método para la pulsación de e elevado a x
     *
     * @param evt Evento
     */
    private void btnEElevadoXActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEElevadoXActionPerformed
        if (verificarOperacion(this, txtResultado.getText(), txtHistorial.getText(), "e^")) {
            {
                // Pasamos el valor del cuadro de texto resultado a un variable BigDecimal
                BigDecimal valor = BigDecimal.valueOf(Math.E);

                // Multiplicamos su valor por -1
                valor = valor.pow(Integer.parseInt(txtResultado.getText()));
                valor = valor.divide(BigDecimal.ONE, PRECISION, RoundingMode.DOWN);

                if (!BigDecimal.ZERO.equals(valor)) {

                    txtResultado.setText(valor.stripTrailingZeros().toPlainString());
                } else {
                    txtResultado.setText("0");
                }

                // Guardamos el resultado en el cuadro de texto correspondiente
                txtResultado.setText(valor.toString());
            }
        }
    }//GEN-LAST:event_btnEElevadoXActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Ejercicio007.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Ejercicio007().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnBorrar;
    private javax.swing.JButton btnCero;
    private javax.swing.JButton btnCinco;
    private javax.swing.JButton btnCoseno;
    private javax.swing.JButton btnCuatro;
    private javax.swing.JButton btnDividir;
    private javax.swing.JButton btnDos;
    private javax.swing.JButton btnE;
    private javax.swing.JButton btnEElevadoX;
    private javax.swing.JButton btnFactorizar;
    private javax.swing.JButton btnIgual;
    private javax.swing.JButton btnInversa;
    private javax.swing.JButton btnLimpiar;
    private javax.swing.JButton btnLogNeperiano;
    private javax.swing.JButton btnLogaritmo;
    private javax.swing.JButton btnMas;
    private javax.swing.JButton btnMasMenos;
    private javax.swing.JButton btnMenos;
    private javax.swing.JButton btnMultiplicar;
    private javax.swing.JButton btnNueve;
    private javax.swing.JButton btnOcho;
    private javax.swing.JButton btnParentesis;
    private javax.swing.JButton btnPi;
    private javax.swing.JButton btnPorcentaje;
    private javax.swing.JButton btnPunto;
    private javax.swing.JButton btnRaizCuadrada;
    private javax.swing.JButton btnSeis;
    private javax.swing.JButton btnSeno;
    private javax.swing.JButton btnSiete;
    private javax.swing.JButton btnTangente;
    private javax.swing.JButton btnTres;
    private javax.swing.JButton btnUno;
    private javax.swing.JButton btnValorAbsoluto;
    private javax.swing.JButton btnXCuadrado;
    private javax.swing.JButton btnYElevadoX;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JLabel txtHistorial;
    private javax.swing.JLabel txtResultado;
    // End of variables declaration//GEN-END:variables

    /**
     * Método que se encarga de pedir el resultado de la cadena de operaciones
     *
     * @param operaciones Cadena de texto con las operaciones a realizar
     * @return Una cadena con el valor de las operaciones
     */
    private String operar(String operaciones) {

        // Llemamos al método parser de la clase ParserCalculadora
        // pasándole la cadena de operaciones a realizar
        Solucion resultado = ParserCalculadora.parser(operaciones);

        // Comprobamos si hay algún mensaje a mostrar al usuario
        if (resultado.getMensaje().equals("")) {
            // Si no lo hay, devolvemos el resultado
            return resultado.getResultado();
        } else {
            // Si lo hay limpiamos y mostramos el mensaje
            txtResultado.setText("");
            nuevaOperacion = true;
            nuevoNumero = true;
            return resultado.getMensaje();
        }
    }

    /**
     * Método pare permitirnos realizar las acciones pertinentes a la hora de
     * introducir una operación en la calculadora
     *
     * @param valorOperacion La operación introducida
     */
    private void operacionPulsada(String valorOperacion) {

        // Comprobamos si es una nueva operación la que se introduce
        if (nuevaOperacion) {

            // Si lo es, reseteamos los cuadros de texto y reseteamos el valor
            // de la variable de control
            txtResultado.setText("");
            txtHistorial.setText("");
            nuevaOperacion = false;
        }

        // Comprobamos el valor de la operación y realizamos acciones en 
        // consecuencia
        switch (valorOperacion) {
            case "(": {

                // Concatenamos el paréntesis al historial
                txtHistorial.setText(txtHistorial.getText() + txtResultado.getText());

                // Guardamos el historial sin espacios al final en una variable 
                // para trabajar con el sin modificarlo
                String hist = txtHistorial.getText().trim();

                // Contamos el número de paréntesis abiertos y cerrados que 
                // tenemos en el historial
                int count = hist.length() - hist.replace("(", "").length();
                int count2 = hist.length() - hist.replace(")", "").length();

                // Verificamos si la longitud del historial es mayor de cero y 
                // que  el último carácter no es un paréntesis abierto o una 
                // operación tras la cual puede haber un paréntesis abierto
                if (hist.length() != 0 && "+-*/(".indexOf(hist.charAt(hist.length() - 1)) == -1) {

                    // Si el historial no es nuevo o el último caracter no es 
                    // una operación que permita un paréntesis, comprobamos si
                    // el último carácter es un dígito.
                    if ("0123456789)".indexOf(hist.charAt(hist.length() - 1)) != -1) {

                        // Si lo es, comprobamos si hay más paréntesis abiertos
                        // que paréntesis cerrados
                        if (count > count2) {

                            // Si es así, ponemos un paréntesis cerrado
                            txtHistorial.setText(txtHistorial.getText() + ")");
                        }
                    }
                } else {
                    // Si el historial es nuevo o la última operación permite un
                    // paréntesis abierto, ponemos uno
                    txtHistorial.setText(txtHistorial.getText() + txtResultado.getText() + "(");
                }
                break;
            }
            case "Inv":
            case "Abs":
            case "Sqr":
            case "Ln":
            case "Log":
            case "Fact":
            case "Sqrt":
            case "Cos":
            case "Sin":
            case "Tan": {
                // En estos casos, concatenamos al cuadro de historial, su valor actual mas el valor de la operación
                // con un parentesis al final, forzando encapsular las operaciones entre paréntesis
                txtHistorial.setText(txtHistorial.getText() + txtResultado.getText() + " " + valorOperacion + "(");
                break;
            }
            case "%": {
                txtHistorial.setText(txtHistorial.getText() + txtResultado.getText() + valorOperacion + " ");
                break;
            }
            default: {
                // En estos casos, concatenamos al cuadro de historial, su valor actual mas el valor de la operación
                txtHistorial.setText(txtHistorial.getText() + txtResultado.getText() + " " + valorOperacion + " ");
                break;
            }

        }

        // Limpiamos el valor que hubiese en el cuadro de texto de resultado
        txtResultado.setText("");

        // Tras introducir la operación, indicamos que a continuación se 
        /// introducirá un nuevo número
        nuevoNumero = true;

        // Hacemos que el Jpanel tenga el foto para poder hacer saltar los eventos
        // de teclado        
        this.requestFocus();

    }

    /**
     * Método que nos permite realizar las acciones pertinentes al pulsar un
     * botón correspondiente a un número
     *
     * @param valorNumero Número pulsado
     */
    private void numeroPulsado(String valorNumero) {

        // Comprobamos si es una nueva operación
        if (nuevaOperacion) {

            // Si lo es, reseteamos los cuadros de texto y reseteamos el valor
            // de la variable de control
            txtResultado.setText("");
            txtHistorial.setText("");
            nuevaOperacion = false;
        }

        // Comprobamos si se introduce un nuevo número, esto es, un número despues
        // de haber introducido una operación
        if (nuevoNumero) {

            // Si lo es, reseteamos el cuadro de texto del resultado y el valor
            // de la variable de control
            txtResultado.setText("");
            nuevoNumero = false;
        }

        // Varificamos el valor del número introducido y concatenamos su valor
        // al cuadro de texto del resultado
        switch (valorNumero) {
            case "Pi":
                txtResultado.setText(txtResultado.getText() + Math.PI);
                break;
            case "e":
                txtResultado.setText(txtResultado.getText() + Math.E);
                break;
            default:
                txtResultado.setText(txtResultado.getText() + valorNumero);
                break;
        }

        // Hacemos que el Jpanel tenga el foto para poder hacer saltar los eventos
        // de teclado
        this.requestFocus();

    }

    /**
     * Método para comprobar si se se acepta la pulsación de un botón de
     * operación en la calculadora, basado en las operaciones anteriores
     *
     * @param parent Objeto padre donde estén situados los botones de la
     * calculadora
     * @param resultado Valor de la etiqueta de resultado de la calculadora
     * @param historial Valor de la etiqueta de historial de la calculadora
     * @param operacion Tipo de operación a verificar
     * @return Verdadero si se puede incluir la operación, falso si no se puede
     */
    private boolean verificarOperacion(Object parent, String resultado, String historial, String operacion) {

        // Definimos una constante para almacenar la expresión regular
        // para verificar la entrada de números
        final String NUMERO = "[-+]?\\d*\\.?\\d+";

        // Definimos e inicializamos la variable de resultado
        boolean salida = false;

        // Limpiamos los espacios en blanco para facilitar la detección de 
        // operaciones
        resultado = resultado.replace(" ", "");

        // Verificamos el tipo de operación
        switch (operacion) {

            // Si es una operación de suma
            case "+":
            // Si es una operación de resta
            case "-":
            // Si es una operación de multiplicación
            case "*":
            // Si es una operación de división
            case "/": {

                // Comprobamos si el texto en el cuadro de resultado es un número                
                if (resultado.matches(NUMERO)) {

                    // Si lo es, se puede poner el tanto por ciento
                    salida = true;
                } else {

                    // Si no es un número, comprobamos si la última operación
                    // introducida es un paréntesis de cierre
                    if (comprobarUltimaOperacion(historial, new String[]{")"})) {

                        // Si es así podemos poner el tanto por ciento
                        salida = true;
                    }
                }
                break;
            }
            // Si es una potencia
            case "^":
            // Si es una potencia de 2           
            case "^2":
            // Si es el tanto por ciento
            case "%": {
                // Comprobamos si el texto en el cuadro de resultado es un número                
                if (resultado.matches(NUMERO) && !nuevaOperacion) {

                    // Si lo es, se puede poner el tanto por ciento
                    salida = true;
                } else {

                    // Si no es un número, comprobamos si la última operación
                    // introducida es un paréntesis de cierre
                    if (comprobarUltimaOperacion(historial, new String[]{")"})) {

                        // Si es así podemos poner el tanto por ciento
                        salida = true;
                    }
                }
                break;
            }

            case "(": {
                if (resultado.equals("") || ("0123456789)".indexOf(resultado.charAt(resultado.length() - 1)) != -1)) {
                    salida = true;
                }

                String[] verificar = new String[]{"(", "+", "*", "*", "/", "^"};
                if (comprobarUltimaOperacion(historial + resultado, verificar)) {
                    salida = true;
                }
                break;
            }

            case "Abs":
            case "Inv":
            case "Log":
            case "Ln":
            case "Sqrt":
            case "Fact":
            case "Tan":
            case "Cos":
            case "Sin": {
                if (nuevaOperacion) {
                    salida = true;
                } else if (resultado.equals("")) {
                    salida = true;
                }

                String[] verificar = new String[]{"(", "+", "*", "*", "/", "^"};
                if (comprobarUltimaOperacion(historial, verificar)) {
                    salida = true;
                }
                break;
            }
            // Si es e elevado a x
            case "e^":
            // Si el botón de número negativos            
            case "neg": {
                // Comprobamos que lo que hay en el cuadro de texto de resultados
                // es un número
                if (resultado.matches(NUMERO) && !nuevaOperacion) {
                    salida = true;
                }
                break;
            }
            default: {
            }
        }

        // Hacemos que el Jpanel tenga el foto para poder hacer saltar los eventos
        // de teclado
        ((JFrame) parent).requestFocus();

        // Devolvemos el resultado
        return salida;

    }

    /**
     * Método para verificar si la cadena contiene como último valor una de las
     * operaciones a verificar
     *
     * @param cadena Cadena con texto
     * @param operaciones Operaciones a verificar
     * @return Verdadero si contiene alguna operación, si no falso
     */
    private boolean comprobarUltimaOperacion(String cadena, String[] operaciones) {
        boolean salida = false;

        // Quitamos los espacios para facilitar la detección
        cadena = cadena.replace(" ", "");

        // Comprobamos si la cadena tiene algún caracter
        if (cadena.length() > 0) {
            // Iteramos por las operaciones a verificar
            for (String operacion : operaciones) {

                // Si el último caracter de la cadena es igual a alguna de 
                // las operaciones cambiamos la variable de salida a verdadero
                // y salimos del bucle
                if (cadena.charAt(cadena.length() - 1) == operacion.charAt(0)) {
                    salida = true;
                    break;
                }

            }
        }

        // Devolvemos el resultado
        return salida;

    }

    /**
     * Método que nos permite verificar el formato de las instrucciones a
     * calcular
     *
     * @param historial Texto del historial de la calculadora
     * @param resultado Texto del resultaod de la calculadora
     * @return Verdadero si es una operación realizable, false si no lo es
     */
    private boolean verficicarFormatoCalculo(String historial, String resultado) {

        boolean salida = true;

        historial = historial.concat(resultado);

        // Contamos el número de paréntesis abiertos y cerrados que 
        // tenemos en el historial
        int count = historial.length() - historial.replace("(", "").length();
        int count2 = historial.length() - historial.replace(")", "").length();

        // Si tenemos cantidad distinta, es que no todos los paréntesis están
        // cerrados
        if (count != count2) {
            salida = false;
        }

        // Comprobamos si el último caracter del historial es una de las siguienntes
        String[] verificar = new String[]{"(", "+", "*", "*", "/", "^"};
        if (comprobarUltimaOperacion(historial, verificar)) {
            // Si es así, no está bien formada
            salida = false;
        }

        // Devolvemos el resultado
        return salida;
    }

    /**
     * Clase para capturar los eventos de teclado al pulsar teclas
     */
    public class ControlTeclado implements KeyListener {

        /**
         * Método para capturar eventos de teclado
         *
         * @param e Evento
         */
        @Override
        public void keyTyped(KeyEvent e) {

        }

        /**
         * Método para capturar la pulsación de una tecla del teclado
         *
         * @param e Evento
         */
        @Override
        public void keyPressed(KeyEvent e) {
            // Comprobamos que tecla se ha pulsado y ejecutamos el evento
            // correspondiente al botón de la calculadora
            switch (e.getKeyChar()) {
                case '1': {
                    btnUnoActionPerformed(null);
                    break;
                }
                case '2': {
                    btnDosActionPerformed(null);
                    break;
                }
                case '3': {
                    btnTresActionPerformed(null);
                    break;
                }
                case '4': {
                    btnCuatroActionPerformed(null);
                    break;
                }
                case '5': {
                    btnCincoActionPerformed(null);
                    break;
                }
                case '6': {
                    btnSeisActionPerformed(null);
                    break;
                }
                case '7': {
                    btnSieteActionPerformed(null);
                    break;
                }
                case '8': {
                    btnOchoActionPerformed(null);
                    break;
                }
                case '9': {
                    btnNueveActionPerformed(null);
                    break;
                }
                case '0': {
                    btnCeroActionPerformed(null);
                    break;
                }
                case '.': {
                    btnPuntoActionPerformed(null);
                    break;
                }
                case '+': {
                    btnMasActionPerformed(null);
                    break;
                }
                case '-': {
                    btnMenosActionPerformed(null);
                    break;
                }
                case '*': {
                    btnMultiplicarActionPerformed(null);
                    break;
                }
                case '/': {
                    btnDividirActionPerformed(null);
                    break;
                }

                default: {
                    // Comprobamos si hemos pulsado el intro para realizar
                    // la operación
                    if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                        btnIgualActionPerformed(null);
                    }
                    if (e.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
                        btnBorrarActionPerformed(null);
                    }
                    break;
                }
            }
        }

        /**
         * Método para capturar eventos de teclado
         *
         * @param e Evento
         */
        @Override
        public void keyReleased(KeyEvent e) {

        }
    }

    /**
     * Clase para realizar las operaciones de una calculadora científica usando
     * cadenas con las operaciones a realizar
     *
     * @author Luis Cabrerizo Gómez
     */
    public static class ParserCalculadora {

        // Variable para controlar la precisión de las divisiones
        private static int precision;

        /**
         * Método para recuperar la precisión en las divisiones de la
         * calculadora
         *
         * @return La pecisión en las divisiones de la calculadora
         */
        public static int getPrecision() {
            return precision;
        }

        /**
         * Método para asignar una precisión a las divisiones de la calculadora
         *
         * @param precision La precisión en las divisiones de la calculadora
         */
        public static void setPrecision(int precision) {
            ParserCalculadora.precision = precision;
        }

        /**
         * Método para analizar las operaciones a realizar y calcular el
         * resultado
         *
         * @param cadena Cadena con las operaciones a realizar
         * @return Cadena con el resultado de las operaciones
         */
        public static Solucion parser(String cadena) {

            // Variable para almacenar algún mensaje al usuario
            String mensaje = "";

            // Variable para almacenar el resultado de salida
            BigDecimal numero1 = BigDecimal.ZERO;

            // Variables para controlar las posiciones de las operaciones buscadas
            int pos1;
            int pos2 = 0;
            int pos3 = 0;

            // Operaciones admitidas por el parseador
            // Las operaciones van ordenados por jerarquía de operaciones
            String operaciones[] = {"N", "(", ")", "!", "A", "Q", "l", "L", "S", "C", "T", "I", "^", "%", "*", "/", "+", "-"};

            // Eliminamos los espacios en blanco
            cadena = cadena.replace(" ", "");

            cadena = transformarNegativos(cadena);

            // Transformamos las representaciones de las las funciones a letras
            // entendibles por el parseador
            cadena = transformarFunciones(cadena);

            // Transformamos la cadena de caracteres a una lista para trabajar
            ArrayList valor = cadenaALista(cadena, operaciones);

            try {

                // Iteraremos mientras haya operaciones en la lista
                do {

                    // Iteramos para cada operación del array de operaciones
                    for (String operacion : operaciones) {

                        // Iteramos mientras haya operaciones del tipo de la iteración
                        // en la lista
                        do {

                            // Comprobamos que la operación este en la lista
                            if (valor.contains(operacion)) {

                                // Si lo está realizaremos busquedas específicas para
                                // cada una de las operaciones
                                switch (operacion) {

                                    case "N": {
                                        // Buscamos el índice de la primera operación en la lista
                                        pos1 = valor.indexOf(operacion);

                                        // Igualamos la posición de corte anterior a la 
                                        // posición de la operación
                                        pos2 = pos1;

                                        // Buscamos cualquiera que sea la siguiente operación de la lista
                                        // desde el índice de la primera operación y el final de la lista
                                        pos3 = pos1 + 1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), new String[]{")"}, true);

                                        numero1 = new BigDecimal(valor.get(pos3 - 1).toString());
                                        numero1 = numero1.multiply(new BigDecimal("-1"));
                                        break;

                                    }

                                    // Si la operación seleccionada es un paréntesis
                                    case "(": {

                                        // Localizamos la posición del último paréntesis
                                        // abierto que haya en la lista
                                        pos1 = valor.lastIndexOf(operacion);

                                        // El valor de la posición de corte anterior
                                        // será la del paréntesis
                                        pos2 = pos1;

                                        // La posición de corte posterior será la siguiente
                                        // operación del resto de la lista, donde buscaremos
                                        // el primer paréntesis cerrado
                                        pos3 = pos1 + 1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), new String[]{")"}, true);

                                        // Dentro de los paréntesis puede haber 
                                        // cualquier conjunto de operaciones, para 
                                        // calcular el valor resultante del paréntesis
                                        // transformamos la lista de valores a una cadena
                                        // y la volvemos a pasar por el parser de forma
                                        // recursiva. 
                                        Solucion retorno = parser(listaACadena(valor.subList(pos2 + 1, pos3)));

                                        // Almacenamos el valor del resultado en nuesta variable para calculos
                                        numero1 = new BigDecimal(retorno.getResultado());

                                        // Y almacenamos el mensaje en la variable de mensajes
                                        mensaje = retorno.getMensaje();

                                        // Si el mensaje contiene algún valor se ha producido un error
                                        if (mensaje != null && !mensaje.equals("")) {
                                            // Modificamos el valor del resultado de la operación
                                            retorno.setResultado("0");

                                            // Y devolvemos el valor, puesto que no
                                            // se puede operar más
                                            return retorno;
                                        }

                                        break;
                                    }
                                    case "I":
                                    case "A":
                                    case "l":
                                    case "L":
                                    case "!":
                                    case "Q": {

                                        // Buscamos el índice de la primera operación en la lista
                                        pos1 = valor.indexOf(operacion);

                                        // Igualamos la posición de corte anterior a la 
                                        // posición de la operación
                                        pos2 = pos1;

                                        // Buscamos cualquiera que sea la siguiente operación de la lista
                                        // desde el índice de la primera operación y el final de la lista
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Comprobamos la operación
                                        switch (operacion) {

                                            // Calculamos la operación necesaria usando
                                            // el valor de la lista correspondiente
                                            case "A": {
                                                numero1 = new BigDecimal(Math.abs(Double.valueOf(valor.get(pos3).toString())));
                                                break;
                                            }
                                            case "!": {
                                                numero1 = factorial(Double.valueOf(valor.get(pos3).toString()));
                                                break;
                                            }
                                            case "Q": {
                                                numero1 = new BigDecimal(Math.sqrt(Double.valueOf(valor.get(pos3).toString())));
                                                break;
                                            }
                                            case "l": {
                                                numero1 = new BigDecimal(Math.log(Double.valueOf(valor.get(pos3).toString())));
                                                break;
                                            }
                                            case "L": {
                                                numero1 = new BigDecimal(Math.log10(Double.valueOf(valor.get(pos3).toString())));
                                                break;
                                            }
                                            case "s": {
                                                numero1 = new BigDecimal(Math.pow((Double.valueOf(valor.get(pos3).toString())), 2));
                                                break;
                                            }
                                            case "I": {
                                                numero1 = BigDecimal.ONE.divide(new BigDecimal(valor.get(pos3).toString()), precision, RoundingMode.HALF_DOWN).stripTrailingZeros();
                                                break;
                                            }
                                            default: {
                                            }
                                        }

                                        // Redondeamos el resultado
                                        if (!BigDecimal.ZERO.equals(numero1)) {
                                            numero1 = numero1.divide(BigDecimal.ONE, precision, RoundingMode.HALF_DOWN).stripTrailingZeros();
                                        }

                                        break;
                                    }
                                    case "T":
                                    case "C":
                                    case "S": {

                                        // Buscamos el índice de la primera operación en la lista
                                        pos1 = valor.indexOf(operacion);

                                        // Igualamos la posición de corte anterior a la 
                                        // posición de la operación                                
                                        pos2 = pos1;

                                        // Buscamos cualquiera que sea la siguiente operación de la lista
                                        // desde el índice de la primera operación y el final de la lista                                
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Pasamos el número a calcular a un double para
                                        // realizar las operaciones
                                        double numero = Double.valueOf(valor.get(pos3).toString());

                                        // Comprobamos el tipo de operación y la realizamos
                                        // tras pasar el número a radianes
                                        switch (operacion) {
                                            case "S": {
                                                numero = Math.sin(Math.toRadians(numero));
                                                break;
                                            }
                                            case "C": {
                                                numero = Math.cos(Math.toRadians(numero));
                                                break;
                                            }
                                            case "T": {
                                                numero = Math.tan(Math.toRadians(numero));
                                                break;
                                            }
                                            default: {
                                            }
                                        }

                                        // Almacenamos el resultado
                                        numero1 = new BigDecimal(numero);

                                        // Redondeamos el resultado
                                        if (!BigDecimal.ZERO.equals(numero1)) {
                                            numero1 = numero1.divide(BigDecimal.ONE, precision, RoundingMode.HALF_DOWN).stripTrailingZeros();
                                        }

                                        break;
                                    }
                                    case "%": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior
                                        pos3 = pos1;

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.divide(new BigDecimal("100"), precision, RoundingMode.HALF_DOWN).stripTrailingZeros();

                                        break;
                                    }
                                    case "+": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.add(new BigDecimal(valor.get(pos3).toString()));
                                        break;
                                    }
                                    case "-": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista                                
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior                                
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos                                
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.subtract(new BigDecimal(valor.get(pos3).toString()));
                                        break;
                                    }
                                    case "*": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista                                                                
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior                                                                
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos                                
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.multiply(new BigDecimal(valor.get(pos3).toString()));
                                        break;
                                    }
                                    case "/": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista                                                                                                
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior                                                                                                
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos                                                                
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.divide(new BigDecimal(valor.get(pos3).toString()), precision, RoundingMode.HALF_DOWN).stripTrailingZeros();
                                        break;
                                    }
                                    case "^": {
                                        // Buscamos el índice de la operación
                                        pos1 = valor.indexOf(operacion);

                                        // Buscamos la operación anterior y nos 
                                        // posicionamos en el siguiente elemento de la 
                                        // lista                                                                                                
                                        pos2 = buscarOperacion(valor.subList(0, pos1), operaciones, false) + 1;

                                        // Buscamos la operación posterior y nos posicionamos
                                        // en el elemento anterior                                                                                                
                                        pos3 = pos1 + buscarOperacion(valor.subList(pos1 + 1, valor.size()), operaciones, true);

                                        // Convertimos los números de antes y despues de
                                        // la operación a BigDecimal y operamos con ellos                                                                
                                        numero1 = new BigDecimal(valor.get(pos2).toString());
                                        numero1 = numero1.pow(Integer.parseInt(valor.get(pos3).toString()));

                                        // Redondeamos el resultado
                                        if (!BigDecimal.ZERO.equals(numero1)) {
                                            numero1 = numero1.divide(BigDecimal.ONE, precision, RoundingMode.HALF_DOWN).stripTrailingZeros();
                                        }

                                        break;
                                    }
                                    default: {
                                    }
                                }

                                // Quitamos los ceros sobrantes y almacenamos el número
                                // posición de corte anterior
                                valor.set(pos2, numero1.toPlainString());

                                // Limpiamos los valores de la lista entre la posición 
                                // de corte anterior + 1 y la posición de corte posterior + 1
                                // eliminando los valores de la lista que se han calculado
                                // y guardando el resultado en la última posición tratada
                                valor.subList(pos2 + 1, pos3 + 1).clear();

                                // Ajustamos la lista si tuviese espacios vacios
                                valor.trimToSize();

                            }
                        } // Seguimos iterando encontremos la operación de la iteración
                        // en la lista
                        while (valor.contains(operacion));
                    }
                } // Seguimos operando mientras haya operaciones
                while (!Collections.disjoint(valor, Arrays.asList(operaciones)));

                // Almacenamos el resultado
                numero1 = new BigDecimal(valor.get(0).toString());

            } catch (NumberFormatException | ArithmeticException e) {
                // Si se produce un error almacenamos el mensaje
                if (mensaje != null) {
                    mensaje = mensaje.concat(e.getMessage());
                } else {
                    mensaje = e.getMessage();
                }
            }

            // Creamos un nuevo objeto salida
            Solucion salida = new Solucion();

            // Inicializamos el mensaje a vacío
            salida.setMensaje("");

            // Comprobamos si tenemos algúm mensaje de error, de ser así
            // lo asignamos al objeto de salida
            if (mensaje != null && !mensaje.equals("")) {
                salida.setMensaje(mensaje);
            }

            // Verificamos que el resultado no sea cero
            if (!BigDecimal.ZERO.equals(numero1)) {
                // Si nolo es, volcamos el resultado a al objeto de salida quitandole
                // los ceros de más y pasandolo como cadena
                salida.setResultado(numero1.stripTrailingZeros().toPlainString());
            } else {
                // Si es cero, ajustamos el resultado del objeto de salida con un 0
                salida.setResultado("0");
            }

            // Y devolvemos la solución
            return salida;
        }

        /**
         * Método para verificar los números negativos de la cadena de
         * operaciones y tratarlos de antemano para convertirlos y no confundir
         * su señalización con operaciones de resta
         *
         * @param cadena Cadena a tratar
         * @return Cadena tratada y con los números negativos convertidos en
         * N(num) para su tratamiento posterior
         */
        private static String transformarNegativos(String cadena) {

            // Creamos un array con los posibles valores de operaciones que existen 
            // en la calculadora a excepción del cierre de paréntesis
            String signos[] = {"N", "(", "!", "A", "Q", "l", "L", "S", "C", "T", "I", "^", "%", "*", "/", "+", "-"};

            // Iteramos por la cadena
            for (int i = 0; i < cadena.length(); i++) {

                // Comprobamos carácter a carácter si hay un símbolo menos
                if (cadena.charAt(i) == '-') {

                    // Para que se trate de un símbolo de negativo, o bien es el 
                    // primero de la cadena de operaciones o esta precedido de una
                    // operación
                    if (i == 0 || Arrays.asList(signos).contains(String.valueOf(cadena.charAt(i - 1)))) {

                        // Definimos una variable que almacenará el tamaño de la cadena
                        // Si no se modifica y llegamos el final de la cadena en la
                        // siguiente iteración, es que es el último número de la
                        // cadena
                        int siguiente = cadena.length();

                        // Iteramos desde la posición del simbolo menos más uno hasta
                        // el fichal de la cadena, comprobando si hay alguna operación
                        for (int j = i + 1; j < cadena.length(); j++) {

                            // Si hay alguna operación almacenamos esta posición
                            // y dejamos de iterar, puesto que solo nos interesa
                            // la siguiente operación para delimintar el número
                            if (Arrays.asList(signos).contains(String.valueOf(cadena.charAt(j)))) {
                                siguiente = j;
                                break;
                            }
                        }
                        // Modificamos la cadena, englobando en número delimintado 
                        // entre paréntesis y antecediendole una N para denotarlo
                        // al parseador como un número negativo
                        cadena = (cadena.substring(0, i) + "N(" + cadena.substring(i + 1, siguiente) + ")" + cadena.substring(siguiente, cadena.length()));

                    }
                }
            }

            // Devolvemos la cadena resultante
            return cadena;
        }

        /**
         * Función para transformar una lista a una cadena
         *
         * @param lista Lista con los valores a transformar
         * @return Una cadena con con los valores de la lista como cadena
         */
        private static String listaACadena(List lista) {
            String cadena = "";

            // Iteramos por la lista
            for (Object object : lista) {

                // Concatenamos los valores de la lista a una cadena
                cadena = cadena.concat(object + "");
            }

            // Devolvemos la cadena con los valores concatenados
            return cadena;
        }

        /**
         * Función para pasar una cadena de texto a una lista, delimitada por
         * las operaciones que pudiera contener
         *
         * @param valor Cadena con las operaciones y dígitos
         * @param operaciones Posibles operaciones que puede contener la cadena
         * @return Lista que tiene el contenido de la cadena delimitado en
         * números y operaciones
         */
        private static ArrayList cadenaALista(String valor, String[] operaciones) {

            // Definimos una lista de tipo cadena donde almacenar los carácteres
            ArrayList<String> chars = new ArrayList<>();
            String cadena = "";

            // Iteramos por los caracteres de la cadena
            for (char c : valor.toCharArray()) {

                // Si la lista de operaciones contiene el caracter de la iteración
                if (Arrays.asList(operaciones).contains(c + "")) {

                    // Comprobamos que la cadena que contiene la suceción de números
                    // no sea vacía
                    if (!cadena.equals("")) {
                        // Si no lo es, la añadimos a la lista como un número completo
                        chars.add(cadena);
                    }

                    // Como es una operación, añadimos la operación tambien a la lista
                    cadena = "";

                    // Añadimos tambien
                    chars.add(c + "");
                } else {

                    // Si no es una operación es un número, y no estará completo 
                    // hasta que no haya una operación, por tanto lo concatenamos
                    cadena = cadena.concat(c + "");
                }
            }

            // Si la cadena es distinta de nulo, la añadimos al final
            // Por si fuese solo una serie de números
            if (!cadena.equals("")) {
                chars.add(cadena);
            }

            // Devolvemos el resultado
            return chars;
        }

        /**
         * Función para buscar la posición de la operación más cercana de una
         * lista dígitos y operaciones
         *
         * @param valores Lista con los dígitos y las operaciones a analizar
         * @param operaciones Operaciones a buscar
         * @param izqDer Para realizar la búsqueda de izquierda a derecha o a la
         * inversa
         * @return Posición de la operación más cercana
         */
        private static int buscarOperacion(List valores, String[] operaciones, boolean izqDer) {

            // Iniciamos la variable de resultado. 
            // Si la búsqueda es de izquierda a derecha, su valor inicial será
            // el tamaño de la lista, si no es así será cero
            int resultado = (izqDer ? valores.size() : 0);

            // Iteramos por todas las operaciones disponibles
            for (String operacion : operaciones) {

                // Varificamos el sentido de la búsqueda
                if (!izqDer) {

                    // Si el índice de la operación del bucle es menor que el valor
                    // almacenado en resultado, eso indica que está más a la derecha
                    // de la lista y seria posterior a la anterior que hubiesemos 
                    // guardado
                    if (resultado < valores.lastIndexOf(operacion)) {

                        // Si esto es asi, guardamos su posición para devolverla al 
                        // final de la función
                        resultado = valores.lastIndexOf(operacion);
                    }
                } else {
                    // Comprobamos inicialmente que la operación está en la lista
                    if (valores.indexOf(operacion) != -1) {

                        // De ser así, comprobamos si su indice es menor que el que 
                        // tenemos almacenado en la variable de resultado, lo cual 
                        // querría decir que la operación es anterior a la que 
                        // habíamos guardado
                        if (resultado > valores.indexOf(operacion)) {

                            // Si esto es así, guardamos la posición para devolverla
                            // al final de la función
                            resultado = valores.indexOf(operacion);
                        }
                    }
                }
            }

            // Si el resultado es cero, eso quiero decir que no había operación
            // en la lista y devolvemos un valor de -1, si tenemos un resultado
            // devolvemos el valor.
            return (resultado == 0 ? -1 : resultado);
        }

        /**
         * Modifica la cadena de texto visible al usuario transformándola en una
         * legible para el parseador de operaciones
         *
         * @param cadena Cadena a transformar
         * @return Cadena transformada
         */
        private static String transformarFunciones(String cadena) {
            String salida = cadena;

            // Cambiamos las funciones por identificativos de una letra
            salida = salida.replace("Sin", "S");
            salida = salida.replace("Cos", "C");
            salida = salida.replace("Tan", "T");
            salida = salida.replace("Fact", "!");
            salida = salida.replace("Sqrt", "Q");
            salida = salida.replace("Ln", "l");
            salida = salida.replace("Log", "L");
            salida = salida.replace("Abs", "A");
            salida = salida.replace("Inv", "I");

            // Devolvemos el resultado
            return salida;
        }

        /**
         * Método para calcular el factorial de un número
         *
         * @param n Número al que calcular el factorial
         * @return Factorial del número introducido
         */
        private static BigDecimal factorial(double n) {

            // Inicializamos la variable de salida
            BigDecimal factorial = BigDecimal.ONE;

            // Iteramos multiplicando el valor de la iteración por el acumulado del
            // factorial hasta llegar al número de entrada
            for (int i = 1; i <= n; i++) {
                factorial = factorial.multiply(BigDecimal.valueOf(i));
            }

            // Devolvemos el resultado
            return factorial;
        }
    }

    /**
     * Clase para almacenar la solución de una operación con calculadora
     *
     * @author Super
     */
    public static class Solucion {

        // Variable para el resultado
        private String resultado;

        // Variables para mensajes varios
        private String mensaje;

        /**
         * Método para recuperar el resultado a una solución
         *
         * @return Resultado
         */
        public String getResultado() {
            return resultado;
        }

        /**
         * Método para asignar un resultado a una solución
         *
         * @param resultado Resultado
         */
        public void setResultado(String resultado) {
            this.resultado = resultado;
        }

        /**
         * Método para recuperar el mensaje generado en la solución
         *
         * @return Mensaje
         */
        public String getMensaje() {
            return mensaje;
        }

        /**
         * Método para asignar un mensaje a una solución
         *
         * @param mensaje Mensaje
         */
        public void setMensaje(String mensaje) {
            this.mensaje = mensaje;
        }

        /**
         * Constructor base de la clase
         */
        public Solucion() {
        }

        /**
         * Constructor de la clase
         *
         * @param resultado Resultado de las operaciones
         * @param mensaje Mensajes a mostrar al usuario
         */
        public Solucion(String resultado, String mensaje) {
            this.resultado = resultado;
            this.mensaje = mensaje;
        }

    }

}
